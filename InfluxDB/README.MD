<div dir="rtl">

# Authors

<div dir="ltr">
AmirHossein Razlighi <br/>
Hooman Keshvari
</div>

# Introduction
<h2>
influx چیست
</h2>
influx به معنای هجوم است و influxDB دیتابیسی است که هجوم داده‌های زمانی را مدیریت می‌کند.
<br />
حال به مفهوم داده‌های زمان محور می پردازیم:
<br /><br />
فرض کنید یک سری داده داریم که هر 10 ثانیه یک بار تغییر کرده و دیتابیس باید تغییرات آنها را  کرده، احتمالات مربوط به تغییرات آتی آنها را بررسی کرده و دوباره داده‌های جدید را در دیتابیس  قرار دهد.
مثلا یک دیتابیس مربوط به هواشناسی را درنظر بگیرید ؛ داده‌های درون این دیتابیس شامل داده‌هایی هستند که در هر ساعت درحال تغییراند و با توجه به تغییرات قبلی تغییرات احتمالی آینده باید پیشبینی شود.
<br /><br />
<div dir="ltr" style="margin: auto; padding:0px"; align: center;>
 <img src="./Images/weather.png" width="1000", height="300">
</div>
<br/>
یا مثلا داده‌های بازار سهام که در هر ثانیه دستخوش تغییر بوده و داده‌ها،تغییرات و تحلیلات به صورت لحظه‌ای باید ثبت شوند.
<br/><br/>
<div dir="ltr" style="margin: auto; padding:0px"; align: center;>
 <img src="./Images/stock.jpeg" width="1000", height="300">
</div>
<br/><br/>
یا مثال دیگری از این قبیل نمودار نوار قلب بیمار است که در هر لحظه باید ذخیره، تحلیل و به داده‌های قبلی اضافه شود تا از کارکرد درست قلب بیمار اطمینان حاصل کنیم.
<br/><br/>
<div dir="ltr" style="margin: auto; padding:0px"; align: center;>
 <img src="./Images/heart.png" width="1000", height="300">
</div>
<br/><br/>
 داده‌های زمان محور به دو صورت زیر هستند
 <li>
 منظم
 <li>
غیرمنظم 
<br/><br/>
داده‌های منظم داده‌هایی هستند که طبق روال منظمی ثبت می‌شوند
<br/>
مثلا فرض کنید یک سرور داریم که هر 10 ثانیه، لاگ‌های کاربران را به ما نشان می‌دهد؛این تغییرات که به صورت منظم در بازه‌های مشخص اتفاق افتاده و ثبت شده‌اند، از نمونه‌های منظم داده‌های زمان محور هستند.
<br/><br/>
از طرفی داده‌های غیرمنظم داده‌هایی بوده که به صورت مناسبتی اتفاق افتاده و در نتیجه دوره تناوب مشخصی ندارند .
<br/>
 مثال نوارقلب بیمار را درنظر بگیرید ؛ ممکن است تغییرات ناگهانی در هر لحظه در آن رخ دهد پس ما تناوب این تغییرات را نمی‌دانیم اما نیاز به ثبت تمامی آنها داریم.
<br/><br/>
 داده‌های زمان محور می‌توانند به صورت خطی یا غیر خطی باشند.
<br/><br/>
هر سه مثال بالا(تغییرات آب و هوا، بازار سهام و نوارقلب)، از بارزترین نمونه‌های داده "زمان محور" بوده که عمدتا در زندگی روزمره از اهمیت ویژه‌ای برخورداراند پس نیاز به ثبت درست و در زمان‌های درست را دارند.
<br/>
حال اگر از دیتابیس‌های عادی برای ثبت این داده‌ها استفاده کنیم، مطمئنا برای این پردازش و تحلیل داده‌ها در طی هر لحظه یا یک زمان مشخص کار سختی پیش رو خواهیم داشت؛ یکی از راهکارها برای ثبت این داده‌ها، InfluxDB بوده که مختص این گونه داده‌ها است.
<br/><br/>
 این نوع از Database، نوعی از پایگاه‌داده‌ است که اصطلاحا به آن Time Series می گویند. یعنی برخلاف اکثر Database هایی که با آنها کار کرده‌ایم، این پایگاه داده، مقدار key را بصورت خودکار و از روی یک سری زمانی، مقدار دهی می‌کند و ما می‌توانیم مجموعه‌ای از value های مختلف را در آن ذخیره کنیم .
<br />
دلیل این کار ( استفاده از سری زمانی ) این است که سرعت query روی دیتابیس را به شدت بالا ببریم و بتوانیم در اموری مثل اپ های Real Time، از آنها استفاده کنیم .
<br />
برای درک تفاوت بین دیتابیس Influx و دیتابیس ها Sql ی، به جدول زیر توجه کنید . این، مجموعه ای از اطلاعات یک سری سیاره است که در یک دیتابیس sql ذخیره شده است :<br/><br/>

<div dir="ltr" style="margin: auto; padding:0px"; align: center;>
 <img src="./Images/sql_db.png" width="1000", height="300">
</div>
<br />
حالا، همین اطلاعات را در یک دیتابیس زمان محور، مثلInflux  ذخیره می‌کنیم . اطلاعات بدین صورت خواهند بود:
<br/><br/>

<div dir="ltr" style="margin: auto; padding:0px"; align: center;>
 <img src="./Images/influx_db.png" width="1000", height="310">
</div>

<br />

# Influx vs other timeseries Databases
برای پردازش داده‌های زمان‌محور، بجز influx،  دیتابیس‌های دیگری نیز وجود دارد که دوتای آنها یعنی Prometheus و Timescale را با هم بررسی می‌کنیم
<br/>
<h2>روش ثبت اطلاعات</h2>
یکی از اصلی‌ترین تفاوت‌های این دیتابیس‌ها، نحوه نوشتن و گرفتن اطلاعات از آنهاست به صورتی که Influx و Timescale از روش push برای این کار استفاده کرده درصورتی که Prometheus از pull استفاده می‌کند.
<br/>
منظور از pull کردن این است که در بازه‌های مشخص از زمان، همه اطلاعات گرفته و ثبت می‌شوند در صورتی که push مستقیماً در تمامی لحظات اطلاعات را در دیتابیس قرار داده پس می‌توان اینطور فرض کرد که قرار گیری اطلاعات با روش pull به صورت گسسته و با روش push به صورت پیوسته است.<br/>
به عنوان مثال فرض کنید می‌خواهیم کارکرد یک cpu را اندازه گیری کنیم؛ Prometheus این اطلاعات را به صورت نقطه های گسسته گرفته و ثبت می‌کند و براساس این نقاط گسسته یک نمودار حدودی از داده‌های ورودی، شامل خطوط صاف رسم می‌کند در صورتی که Influx، به صورت مستقیم در هر لحظه این اطلاعات را ثبت کرده پس داده‌ها به صورت پیوسته و کامل در دیتابیس ذخیره می‌شوند
<br/>
حال روش pull در مواقعی به کار می‌اید که تغییرات زیادی در داده‌ها نداشته باشیم و نیاز به تحلیل خیلی دقیق داده‌ها نباشد، در این صورت فضای استفاده شده بهینه می‌شود اما در مواقعی که نیاز به نمودار پیوسته و کاملی از داده‌ها داریم، مثلا در سنجش کامل عملکرد یک cpu  طی یک زمان مشخص، روش push اطلاعات، تحلیل‌های کامل‌تری در اختیار ما قرار می‌دهد.
<br/>
<h2>شمارنده‌ها</h2>
یکی از ویژگی‌های خوب در Prometheus شمارنده آن است به صورتی که داده‌های گرفته شده هر بار، اطلاعات قبلی در خود را نیز شامل شده و یک شمارنده برای جمع اطلاعات وجود دارد تا در صورت گم شدن یک سری داده، بتوانیم آنها را دوباره ساخته و جبران کنیم.
<h2>تایپ داده‌ها</h2>
در Prometheus تنها می‌توان داده از نوع float64 را ذخیره کرد در صورتی که در Influx، از ثبت داده با نوع‌های float , string و integer هم پشتیبانی می‌شود
<h2>TimescaleDB</h2>
این دیتابیس از نظر کارکرد و ثبت اطلاعات مانند Influx است با این تفاوت که برای کرفتن اطلاعات می‌توان درست مانند گرفتن از یک دیتابیس sql عمل کرد اما در مقایسه با دیگر دیتابیس‌های زمانی از نظر زمانی سرعت کمتر و از نظر حافظه، بهینه‌سازی فضای کمتر دارد 
<br/><br/>

# Usage of Influx in real world

در حال حاضر شرکت‌هایی از جمله NVIDIA و Intel از این دیتابیس استفاده کرده تا عملکرد قطعات خود را مورد سنجش قرار دهند.
<br/>
شرکت‌های مالی نیز برای ثبت و تحلیل داده‌ها از این دیتابیس استفاده می‌کنند که می‌توان به J.P. Morgan در این امر اشاره کرد.

 
# Setting Up Influx Db in Docker

در این مقاله، تصمیم داریم یک دیتابیس influx را در فضای داکر، بالا آورده، config کنیم و در نهایت، از رابط آن استفاده کنیم و با Data کار کنیم .
به این منظور، داکر را run می‌کنیم و دستور زیر را میزنیم :
<br />
<br />

<div dir="ltr">
    <code>
        docker pull influxdb
    </code>
</div>

حالاباید منتظر باشیم تا آخرین نسحه ی stable یا به اصطلاح همان latest version روی سیستم بارگزاری شود.
پس از آن، برای ساختن یک container از روی image دانلود شده، دستور زیر را میزنیم :
<br /> <br />

<div dir="ltr">
 <code>
 docekr run -d -e INFLUXDB_ADMIN_USER:admin -e INFLUXDB_ADMIN_PASSWORD:admin --name influxdb influxdb
 </code>
</div>

<br />
حالا، یک داکر کانتینر با نام Influxdb و با یوزرنیم و پسورد admin  از روی image دانلود شده، ساخته شد .
<br />
حالا کافی است که دستور زیر را بزنیم :
<br />
<br />

<div dir="ltr">
<code>
    docekr ps -a
</code>
</div>
و با این دستور، تمامی کانتینر های شما، به شما نمایش داده میشوند .  حالا کافی است چند حرف از ابتدای آیدی کانتینر خود را کپی کنید (یا نام کانتینر را کپی کنید ) و دستور زیر را بزنید : 
<br /><br />
<div dir="ltr">
<code>
    docekr exec -it influxdb bash
</code>
</div><br />
در نهایت، کافی است در bash باز شده،  دستور زیر را بزنید ( در تمامی مراحل توجه کنید که فلگ it مخفف interactive است) :

<br /><br />

<div dir="ltr">
<code>
    influx -host localhost -port 8086 -username admin -password admin
</code>
</div><br />

خوب است بدانید که پورت دیفالت مربوط به influx db، همان‌طور که در بالا دیدید، پورت 8086 است .
<br />
حالا، ما وارد shell مربوط به influx db شده ایم و می‌توانیم داده های خود را در آن ذخیره کنیم !

# Simple Instructions in Influx

اولین چیزی که روی شل مشاهده می‌کنید، چیزی شبیه به زیر است :

<br /><br />

<div dir="ltr">
<code>
    Connected To http://localhost:8086 version 1.8.0
    Influx DB Shell : version 1.8.0
</code>
</div><br />

که در همین ابتدا خوب است اشاره کنیم که همه چیز در influx db، تحت پروتکل http رد و بدل می‌شود .
<br />

در همین حال، می‌توانید با دستور زیر، لیست تمامی دیتابیس ها را مشاهده کنید :

<br /><br />

<div dir="ltr">
<code>
    show databases
</code>
</div><br />

در ابتدا، اگر دیتابیسی نساخته باشیم، لیست زیر نمایش داده می‌شود.

<br />
<div dir="ltr">
<code>
    name : databases<br/>
    name<br />
    ------ <br/>
    _internal
</code>
</div><br />

که نشان دهنده ی این است که فعلا، فقط همان دیتابیس دیفالت سیستم، یعنی \_internal وجود دارد .
<br />
حالا، برای ساخت یک دیتابیس جدید، از دستور زیر استفاده می‌کنیم ( مثلا نام دیتابیس خود را demo میگذاریم ) :
<br /><br />

<div dir="ltr">
<code>
    create database demo
</code>
</div><br />

حالا اگر یک show databases بزنیم، میبینیم که زیر \_internal، یک دیتابیس جدید به نام مورد نظر ما ( demo ) نوشته شده است .
<br />
حالا با دستور زیر می‌توانیم وارد دیتابیشس مورد نظرمان بشویم :

<br />

<div dir="ltr">
<code>
    use [database name] <br/> ( e.g : use demo )
</code>
</div><br />
در دیتابیس های InfluxDB، از مفهومی به نام measurments استفاده می‌شود . این مفهوم یعنی داده هایی که در دیتابیس ذخیره می‌کنیم .  این داده ها از آنجایی که فقط مقدار دهی value شان با ماست، یک سری tag هم قبول می‌کنند که به آنها اضافه کنیم و همچنین یک نام که برای دسترسی به آن measurement از آن استفاده کنیم . مثلا در زیر، یک داده با نام CPU را با تگ های host = server A , region = us_west  و با مقدار ( value ) برابر 0.64 ذخیره می‌کنیم :

<br />
<div dir="ltr">
<code>
    insert cpu, host=serverA, region=us_west,<br/> value= 0.64 
</code>
</div><br />

پس فرمت کلی insert کردن داخل دیتابیس به این صورت است :

<br />

<div dir="ltr">
<code>
    insert [measurement name], [tags] [fields = ...]
</code>
</div><br />
حالا می‌توانیم برای کوئری زدن از دستورات sql ی استفاده کنیم ! ( و این از ویژگی های منحصر بفرد آن است ) : 
<br />
مثال :

<br />

<div dir="ltr">
<code>
    SELECT * FROM "cpu"
</code>
</div><br />
به doube quotation دور نام measurement توجه کنید !
حال، بیایید و یک value دیگر را به این measurement اضافه کنیم !

<br />

<div dir="ltr">
<code>
    insert cpu, host= serverA, region= us_west, <br/>value= 1.64
</code>
</div><br />

حالا اگر دستور select \* را بزنیم، چیزی شبیه زیر به نمایش در میاید :

<br />

<div dir="ltr">
<code>
    name: cpu <br/>
    time | host | region | value <br /> 
    -----------------------------------
    <br/>
    [time 2]     |     serverA  |  us_west | 0.64
    <br/>
    [time 1]     |     serverA   |  us_west  | 1.64
</code>
</div><br />

حالا بیایید کمی بیشتر داده در این دیتابیس ذخیره کنیم :

<br />

<div dir="ltr">
<code>
    insert temperature, machine=unit42, type=assembly external=25, internal=37
</code>
</div><br />
<div dir="ltr">
------------------------------------------------------------------------
</div>
<br/>
<div dir="ltr">
<code>
    insert stock, symbol=AAPL bid=127.46, ask=127.86
</code>
</div><br />
<div dir="ltr">
------------------------------------------------------------------------
</div>
<br/>
<div dir="ltr">
<code>
    show measurements
</code>
</div><br />

نتیجه مطابق زیر می‌شود :
<br/>
<div dir="ltr">
<code>
    cpu <br/>
    stock <br/>
    temperature
</code>
</div><br />

حالا، مثلا stock را مشاهده می‌کنیم :
<br/>
<div dir="ltr">
<code>
    SELECT * FROM "stock"
</code>
</div><br />
نتیجه :
<br/>
<img src="./Images/stock_1.png">
همان‌طور که میبینید، یک measurement می‌تواند دو یا چمد value با نام های مختلف داشته باشد و این ویژگی هم دست ما را در کار با داده ها باز میگذارد !
<br />
حال فرض کنید می‌خواهیم تمامی key های هر measurement را مشاهده کنیم . در اینجا می‌توانیم از یک syntax خاص به نام FLUX استفاده کنیم . مثلا :
<br/>
<div dir="ltr">
<code>
    show tag keys
</code>
</div><br />
و نتیجه مطابق زیر است که در هر measurement، نام تگ های مورد نظر را که تعریف شده اند، نشان میدهد :
<br />
<img src="./Images/show_tag_keys.png" />
یا می‌توانستیم تگ های یک measurement هاص را ببینیم . مثلا :
<br/>
<div dir="ltr">
<code>
    show tag keys from "cpu"
</code>
</div><br />
 و نتیجه، تگ های host , region که مربوط به cpu هستند را نمایش میدهد.
 <br/>
 دستوری شبیه به این دستور هست که می‌توانیم بجای tag ها، field ها یا همان مقدار هایی که برای این measurement در نظر گرفته ایم را ببینیم :
 <br/>
<div dir="ltr">
<code>
    show field keys from "cpu"
</code>
</div><br />
و نتیجه مطابق زیر خواهد بود :
<img src="./Images/field_keys_cpu.png">
که همان‌طور که مشاهده می‌شود، مقدار field با نام value را که تغریف کرده بودیم، بعلاوه ی نوع data type آن که غدد اعشاری (float) است، نمایش میدهد .
<br />
حالا بیایید کمی دستورات بیشتری استفاده کنیم تا داده هایمان را مدیریت کنیم:
 <br/>
<div dir="ltr">
<code>
    insert cpu,host=serverA,region=us_east value=0.64
</code>
</div><br />
<div dir="ltr">
------------------------------------------------------------------------
</div>
<div dir="ltr">
<code>
    show tag values from "cpu" with key in ("region")
</code>
</div><br />
و نتیجه مطابق زیر می‌شود ( نشان دادن مقادیر محتلف Tag مربوط به region در measurement با نام cpu ):

<img src="./Images/show_tag_cpu.png">
در INFLUXDB، هر measurement یک سری policy دارد که برخی از آنها auto generate هستند و برخی دیگر را می‌توان بنابر نیاز، بصورت custom نوشت .
مثلا به retention policy توجه کنید . این یک policy است که نشان میدهد یک data به چه مدت توسط influx db نگهداری شود .
<div dir="ltr">
<code>
    show retention policies
</code>
</div><br />
نتیجه چیزی مطابق زیر خواهد بود :
<br />
<img src="./Images/ret_policies.png" >
همان‌طور که میبینید، بصورت default، مقدار duration در اینجا برابر 0 ثانیه است . به این معنی که داده ای که ذخیره می‌شود، هیچگاه از بین نمیرود . گرچه بسیاری موارد ممکن است که نیاز باشد داده پس از مدتی ( مثلا یک هفته یا یک سال) از دیتابیس ما حذف شود .<br /><br />



</div>
